[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/pengju/Downloads/hw/src/main/scala/fp1.scala","languageId":"scala","version":1,"text":"// GENERATED\n/* INSTRUCTIONS\n *\n * Complete the exercises below.  For each \"EXERCISE\" comment, add code\n * immediately below the comment.\n *\n * Please see README.md for instructions, including compilation and testing.\n *\n * GRADING\n *\n * 1. Submissions MUST compile using SBT with UNCHANGED configuration and tests\n *    with no compilation errors.  Submissions with compilation errors will\n *    receive 0 points.  Note that refactoring the code will cause the tests to\n *    fail.\n *\n * 2. You MUST NOT edit the SBT configuration and tests.  Altering it in your\n *    submission will result in 0 points for this assignment.\n *\n * 3. You MUST NOT use while loops or (re)assignment to variables (you can use\n *    \"val\" declarations, but not \"var\" declarations).  You must use recursion\n *    instead.\n *\n * 4. You may declare auxiliary functions if you like.\n *\n * SUBMISSION\n *\n * 1. Submit this file on D2L before the deadline.\n *\n * 2. Late submissions will not be permitted because solutions will be discussed\n *    in class.\n *\n */\nimport java.util.NoSuchElementException\nobject fp1:\n\n  // Here is a utility function for logging recursive functions.\n  // It may be helpful while debugging\n  // Don't use this in the solutions you include in your final submission.\n  def log[X](prefix: String)(computeResult: => X) =\n    println(prefix)\n    val result = computeResult\n    println(s\"$prefix : $result\")\n    result\n  // Note: computeResult is a \"by-name\" parameter.  We will discuss these\n  // later in the course.  Short version: a by-name parameter is non-strict;\n  // it is reevaluated every time it is used in the function body.\n\n  // EXAMPLE: here is the definition of the factorial function.\n  def fact(n: Int): Int =\n    if n <= 1 then 1\n    else n * fact(n - 1)\n\n  // EXAMPLE: factorial with logging\n  def factLog(n: Int): Int =\n    log(s\"fact($n)\") {\n      if n <= 1 then 1\n      else n * factLog(n - 1)\n    }\n\n  // Note that the fact computes as follows (leaving out some steps):\n  //\n  // fact (5)\n  // --> if 5 <= 1 then 1 else 5 * fact (5 - 1)\n  // --> if false then 1 else 5 * fact (5 - 1)\n  // --> 5 * fact (5 - 1)\n  // --> 5 * fact (4)\n  // --> 5 * (if 4 <= 1 then 1 else 4 * fact (4 - 1))\n  // --> 5 * (4 * fact (3))\n  // --> 5 * (4 * (3 * fact (2))\n  // --> 5 * (4 * (3 * (2 * fact (1)))\n  // --> 5 * (4 * (3 * (2 * (if 1 <= 1 then 1 else 1 * fact (1 - 1)))))\n  // --> 5 * (4 * (3 * (2 * (if true then 1 else 1 * fact (1 - 1)))))\n  // --> 5 * (4 * (3 * (2 * 1)))\n  // --> 5 * (4 * (3 * 2))\n  // --> 5 * (4 * 6)\n  // --> 5 * 24\n  // --> 120\n  //\n  // We can get the same answer with less work by starting at the base case and\n  // computing up:\n  //\n  // fact (1) --> 1\n  // fact (2) --> 2 * fact (1) --> 2 * 1 --> 2\n  // fact (3) --> 3 * fact (2) --> 3 * 2 --> 6\n  // fact (4) --> 4 * fact (3) --> 4 * 6 --> 14\n  // fact (5) --> 5 * fact (4) --> 5 * 24 --> 120\n\n  // EXERCISE 1: complete the following definition, so that factTest is the list\n  // of integers List(1,2,6,24,120).\n  //\n  // You must call the \"fact\" function (five times) defined above instead of\n  // hardcoding the numbers 1,2,6,24,120.\n  val factTest: List[Int] =\n    // TODO: Change \"Nil\" to the correct answer.\n    fact(1) :: fact(2) :: fact(3) :: fact(4) :: fact(5) :: Nil\n\n  // EXERCISE 2: complete the following definition of the Fibonacci function.\n  // You can use the mathematical definition of Fib:\n  // https://en.wikipedia.org/wiki/Fibonacci_number\n  //\n  // fib(0) == 0\n  // fib(1) == 1\n  // fib(n) == fib(n-1) + fib(n-2), if n>1\n  def fib(n: Int): Int =\n    // TODO: Provide definition here.\n    // throw UnsupportedOperationException()\n    n match {\n      case 0 => 0\n      case 1 => 1\n      case _ => fib(n - 1) + fib(n - 2)\n    }\n  // EXERCISE 3: declare the identifier \"p1\" with a pair consisting of the\n  // Int 7 and the String \"hello\"\n  val p1: (Int, String) =\n    // TODO: Provide definition here.\n    (7, \"hello\")\n\n  // EXERCISE 4: declare the identifier \"t1\" with a triple consisting of the\n  // Int 7, the String \"hello\", and the Boolean false\n  val t1: (Int, String, Boolean) =\n    // TODO: Provide definition here.\n    (7, \"hello\", false)\n\n  // EXERCISE 5: write a function \"swap\" that takes a pair of an Int and a\n  // String, and returns a pair of a String and an Int (with the values from\n  // the pair passed an argument.\n  //\n  // E.g., swap (p1) should return (\"hello\", 7).  You can use \"p._1\" and\n  // \"p._2\" to access the first and second components of a pair.\n  def swap(p: (Int, String)): (String, Int) =\n    // TODO: Provide definition here.\n    (p._2, p._1)\n\n  // EXERCISE 6: write a function \"sum\" that takes a list of integers and\n  // sums them.\n  //\n  // As with all of the exercises in this assignment, your function MUST be\n  // recursive and MUST NOT use a while loop.\n  def sum(xs: List[Int]): Int =\n    \n    // TODO: Provide definition here.\n    if (xs.isEmpty) then 0 else xs.head + sum(xs.tail)\n  // EXERCISE 7: given the definition of the function \"sumTailAux\" below,\n  // complete the definition of the function \"sumTail\" so that it also sums a\n  // list of integers.\n  //\n  // You must not alter the definition of \"sumTailAux\".\n  //\n  // Your definition for \"sumTail\" must call \"sumTailAux\" directly, and must\n  // not call \"sum\"\n  def sumTailAux(xs: List[Int], accumulator: Int): Int =\n    xs match\n      case Nil     => accumulator\n      case y :: ys => sumTailAux(ys, accumulator + y)\n\n  def sumTail(xs: List[Int]): Int =\n    // TODO: Provide definition here.\n    // throw UnsupportedOperationException()\n    sumTailAux(xs, 0)\n  // EXERCISE 8: complete the following definition of the function \"max\" that\n  // finds the maximum integer in a list of integers.\n  //\n  // If the list is empty, throw a java.util.NoSuchElementException (with no\n  // argument).\n  //\n  // Your function MUST be recursive and MUST NOT use a while loop.\n  //\n  // You MUST NOT use the \"max\" method on lists, but can use the \"max\" method\n  // on integers: That is, you cannot use (xs.max) or similar.  But you can\n  // use (1 max 2).\n  def max(xs: List[Int]): Int =\n    // TODO: Provide definition here.\n    if (xs.isEmpty) then throw NoSuchElementException()\n    else if (xs.length == 1) then xs.head\n    else xs.head max max(xs.tail)\n\n  // EXERCISE 9: given the definition of the function \"maxTail\" below,\n  // complete the definition of the function \"maxTailAux\" so that \"maxTail\"\n  // also finds the maximum of a list of integers.\n  //\n  // You must not alter the definition of \"maxTail\".\n  //\n  // Your definition for \"maxTailAux\" must be recursive and not use while\n  // loops.\n  def maxTailAux(xs: List[Int], accumulator: Int): Int =\n    // TODO: Provide definition here.\n    // throw UnsupportedOperationException()\n    if (xs.isEmpty) then accumulator\n    else maxTailAux(xs.tail, accumulator max xs.head)\n\n  def maxTail(xs: List[Int]): Int =\n    xs match\n      case Nil     => throw NoSuchElementException()\n      case y :: ys => maxTailAux(ys, y)\n\n  // EXERCISE 10: Write a recursive function \"otpu\" (\"upto\" backwards) that\n  // takes two Int parameters \"start\" and \"end\" and produces a \"List[Int]\"\n  // that counts DOWN from \"start\" to \"end\" (inclusive at both ends) one at a\n  // time.\n  //\n  // If \"start < end\", the empty list must be returned.\n  //\n  // For example:\n  // - otpu(10,5) == List(10,9,8,7,6,5)\n  // - otpu(10,11) == Nil\n  def otpu(start: Int, end: Int): List[Int] =\n    // TODO: Provide definition here.\n    // throw UnsupportedOperationException()\n    if (start < end) then Nil \n    else start :: otpu(start - 1, end) "}})[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@69d667a5, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/pengju/Downloads/hw/src/main/scala/fp2.scala","languageId":"scala","version":1,"text":"  // GENERATED\n/* INSTRUCTIONS\n *\n * Complete the exercises below.  For each \"EXERCISE\" comment, add\n * code immediately below the comment.\n *\n * Please see README.md for instructions, including compilation and testing.\n *\n * GRADING\n *\n * 1. Submissions MUST compile using SBT with UNCHANGED configuration and\n *    tests with no compilation errors.  Submissions with compilation errors\n *    will receive 0 points.  Note that refactoring the code will cause the\n *    tests to fail.\n *\n * 2. You MUST NOT edit the SBT configuration and tests.  Altering it in your\n *    submission will result in 0 points for this assignment.\n *\n * 3. You MUST NOT use while loops or (re)assignment to variables (you can\n *    use \"val\" declarations, but not \"var\" declarations).  You must use\n *    recursion instead.\n *\n * 4. You may declare auxiliary functions if you like.\n *\n * SUBMISSION\n *\n * 1. Submit this file on D2L before the deadline.\n *\n * 2. Late submissions will not be permitted because solutions will be\n *    discussed in class.\n *\n */\n\nimport java.util.NoSuchElementException\nobject fp2:\n\n  // EXERCISE 1: complete the following recursive definition of a \"map\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \"map\" method.\n  //\n  // Your implementation of \"map\" MUST be recursive.\n  def map[A, B](xs: List[A], f: A => B): List[B] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 2: complete the following recursive definition of a \"filter\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \"filter\" method.\n  //\n  // Your implementation of \"filter\" MUST be recursive.\n  def filter[A](xs: List[A], f: A => Boolean): List[A] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 3: complete the following recursive definition of an \"append\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \":::\" method.\n  //\n  // Your implementation of \"append\" MUST be recursive.\n  //\n  // HINT: use \"::\" in the body of the cons-cell case.\n  def append[A](xs: List[A], ys: List[A]): List[A] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 4: complete the following recursive definition of a \"flatten\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \"flatten\" method.\n  //\n  // Your implementation of \"flatten\" MUST be recursive.\n  //\n  // HINT: use either \":::\" or your definition of \"append\" in the body of the\n  // cons-cell case.\n  //\n  // EXAMPLE:\n  // - flatten (List ((1 to 5).toList, (6 to 10).toList, (11 to 15).toList)) == (1 to 15).toList\n  def flatten[A](xss: List[List[A]]): List[A] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 5: complete the following recursive definition of a \"foldLeft\"\n  // function for Scala's builtin list type.  You must not use the builtin\n  // \"foldLeft\" method.\n  //\n  // Your implementation of \"foldLeft\" MUST be recursive.\n  //\n  // HINT:   foldLeft (  Nil, e, f) == e\n  //         foldLeft (y::ys, e, f) == foldLeft (ys, f (e, y), f)\n  def foldLeft[A, B](xs: List[A], e: B, f: (B, A) => B): B =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 6: complete the following recursive definition of a \"foldRight\"\n  // function for Scala's builtin list type.  You must not use the builtin\n  // \"foldRight\" method.\n  //\n  // Your implementation of \"foldRight\" MUST be recursive.\n  //\n  // HINT:   foldRight (  Nil, e, f) == e\n  //         foldRight (y::ys, e, f) == f (y, foldRight (ys, e, f))\n  def foldRight[A, B](xs: List[A], e: B, f: (A, B) => B): B =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 7: complete the following definition of a \"joinTerminateRight\"\n  // function to take a list of strings \"xs\" and concatenate all strings\n  // using a string \"term\" as a terminator (not delimiter) between strings.\n  //\n  // You MUST use your foldRight defined above.\n  //\n  // You MAY NOT use recursion.\n  //\n  // EXAMPLES:\n  // - joinTerminateRight (Nil, \";\") == \"\"\n  // - joinTerminateRight (List (\"a\"), \";\") == \"a;\"\n  // - joinTerminateRight (List (\"a\",\"b\",\"c\",\"d\"), \";\") == \"a;b;c;d;\"\n  def joinTerminateRight(xs: List[String], term: String): String =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 8: complete the following definition of a \"joinTerminateLeft\"\n  // function to take a list of strings \"xs\" and concatenate all strings\n  // using a string \"term\" as a terminator (not delimiter) between strings.\n  //\n  // You MUST use your foldLeft defined above.\n  //\n  // You MAY NOT use recursion.\n  //\n  // EXAMPLES:\n  // - joinTerminateLeft (Nil, \";\") == \"\"\n  // - joinTerminateLeft (List (\"a\"), \";\") == \"a;\"\n  // - joinTerminateLeft (List (\"a\",\"b\",\"c\",\"d\"), \";\") == \"a;b;c;d;\"\n  def joinTerminateLeft(xs: List[String], term: String): String =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 9: complete the following recursive definition of a\n  // \"firstNumGreaterThan\" function to find the first number greater than or\n  // equal to \"a\" in a list of integers \"xs\".\n  //\n  // If the list is empty or there is no number greater than or equal to \"a\",\n  // throw a java.util.NoSuchElementException (with no argument).\n  //\n  // Your implementation of \"firstNumGreaterThan\" MUST be recursive.\n  //\n  // EXAMPLES:\n  // - firstNumGreaterThan (5, List (4, 6, 8, 5)) == 6\n  def firstNumGreaterThan(a: Int, xs: List[Int]): Int =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 10: complete the following recursive definition of a\n  // \"firstIndexNumGreaterThan\" function to find the index (position) of the\n  // first number greater than or equal to \"a\" in a list of integers \"xs\".\n  //\n  // The first index should be zero (not one).\n  //\n  // If the list is empty or there is no number greater than or equal to \"a\",\n  // throw a java.util.NoSuchElementException (with no argument).\n  //\n  // Your implementation of \"firstIndexNumGreaterThan\" MUST be recursive.\n  //\n  // EXAMPLES:\n  // - firstIndexNumGreaterThan (5, List (4, 6, 8, 5)) == 1\n  //\n  // HINT: this is a bit easier to write if you use an auxiliary function.\n  def firstIndexNumGreaterThan(a: Int, xs: List[Int]): Int =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/Users/pengju/Downloads/hw/target/scala-3.0.1/zinc/inc_compile_3.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed Sep 22, 2021, 5:53:44 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m
