[0m[[0m[0mdebug[0m] [0m[0m> Exec(console, Some(f10f0921-5ae5-41d2-8515-65e1fd8d4056), Some(CommandSource(console0)))[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / console[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@1c58d7be, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, shutdown, [false,null])[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, shutdown, [true,null])[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/pengju/Downloads/hw/src/main/scala/fp1.scala","languageId":"scala","version":1,"text":"// GENERATED\n/* INSTRUCTIONS\n *\n * Complete the exercises below.  For each \"EXERCISE\" comment, add code\n * immediately below the comment.\n *\n * Please see README.md for instructions, including compilation and testing.\n *\n * GRADING\n *\n * 1. Submissions MUST compile using SBT with UNCHANGED configuration and tests\n *    with no compilation errors.  Submissions with compilation errors will\n *    receive 0 points.  Note that refactoring the code will cause the tests to\n *    fail.\n *\n * 2. You MUST NOT edit the SBT configuration and tests.  Altering it in your\n *    submission will result in 0 points for this assignment.\n *\n * 3. You MUST NOT use while loops or (re)assignment to variables (you can use\n *    \"val\" declarations, but not \"var\" declarations).  You must use recursion\n *    instead.\n *\n * 4. You may declare auxiliary functions if you like.\n *\n * SUBMISSION\n *\n * 1. Submit this file on D2L before the deadline.\n *\n * 2. Late submissions will not be permitted because solutions will be discussed\n *    in class.\n *\n */\nimport java.util.NoSuchElementException\nobject fp1:\n\n  // Here is a utility function for logging recursive functions.\n  // It may be helpful while debugging\n  // Don't use this in the solutions you include in your final submission.\n  def log[X](prefix: String)(computeResult: => X) =\n    println(prefix)\n    val result = computeResult\n    println(s\"$prefix : $result\")\n    result\n  // Note: computeResult is a \"by-name\" parameter.  We will discuss these\n  // later in the course.  Short version: a by-name parameter is non-strict;\n  // it is reevaluated every time it is used in the function body.\n\n  // EXAMPLE: here is the definition of the factorial function.\n  def fact(n: Int): Int =\n    if n <= 1 then 1\n    else n * fact(n - 1)\n\n  // EXAMPLE: factorial with logging\n  def factLog(n: Int): Int =\n    log(s\"fact($n)\") {\n      if n <= 1 then 1\n      else n * factLog(n - 1)\n    }\n\n  // Note that the fact computes as follows (leaving out some steps):\n  //\n  // fact (5)\n  // --> if 5 <= 1 then 1 else 5 * fact (5 - 1)\n  // --> if false then 1 else 5 * fact (5 - 1)\n  // --> 5 * fact (5 - 1)\n  // --> 5 * fact (4)\n  // --> 5 * (if 4 <= 1 then 1 else 4 * fact (4 - 1))\n  // --> 5 * (4 * fact (3))\n  // --> 5 * (4 * (3 * fact (2))\n  // --> 5 * (4 * (3 * (2 * fact (1)))\n  // --> 5 * (4 * (3 * (2 * (if 1 <= 1 then 1 else 1 * fact (1 - 1)))))\n  // --> 5 * (4 * (3 * (2 * (if true then 1 else 1 * fact (1 - 1)))))\n  // --> 5 * (4 * (3 * (2 * 1)))\n  // --> 5 * (4 * (3 * 2))\n  // --> 5 * (4 * 6)\n  // --> 5 * 24\n  // --> 120\n  //\n  // We can get the same answer with less work by starting at the base case and\n  // computing up:\n  //\n  // fact (1) --> 1\n  // fact (2) --> 2 * fact (1) --> 2 * 1 --> 2\n  // fact (3) --> 3 * fact (2) --> 3 * 2 --> 6\n  // fact (4) --> 4 * fact (3) --> 4 * 6 --> 14\n  // fact (5) --> 5 * fact (4) --> 5 * 24 --> 120\n\n  // EXERCISE 1: complete the following definition, so that factTest is the list\n  // of integers List(1,2,6,24,120).\n  //\n  // You must call the \"fact\" function (five times) defined above instead of\n  // hardcoding the numbers 1,2,6,24,120.\n  val factTest: List[Int] =\n    // TODO: Change \"Nil\" to the correct answer.\n    Nil\n\n  // EXERCISE 2: complete the following definition of the Fibonacci function.\n  // You can use the mathematical definition of Fib:\n  // https://en.wikipedia.org/wiki/Fibonacci_number\n  //\n  // fib(0) == 0\n  // fib(1) == 1\n  // fib(n) == fib(n-1) + fib(n-2), if n>1\n  def fib(n: Int): Int =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 3: declare the identifier \"p1\" with a pair consisting of the\n  // Int 7 and the String \"hello\"\n  val p1: (Int, String) =\n    // TODO: Provide definition here.\n    (-1, \"\")\n\n  // EXERCISE 4: declare the identifier \"t1\" with a triple consisting of the\n  // Int 7, the String \"hello\", and the Boolean false\n  val t1: (Int, String, Boolean) =\n    // TODO: Provide definition here.\n    (-1, \"\", true)\n\n  // EXERCISE 5: write a function \"swap\" that takes a pair of an Int and a\n  // String, and returns a pair of a String and an Int (with the values from\n  // the pair passed an argument.\n  //\n  // E.g., swap (p1) should return (\"hello\", 7).  You can use \"p._1\" and\n  // \"p._2\" to access the first and second components of a pair.\n  def swap(p: (Int, String)): (String, Int) =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 6: write a function \"sum\" that takes a list of integers and\n  // sums them.\n  //\n  // As with all of the exercises in this assignment, your function MUST be\n  // recursive and MUST NOT use a while loop.\n  def sum(xs: List[Int]): Int =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 7: given the definition of the function \"sumTailAux\" below,\n  // complete the definition of the function \"sumTail\" so that it also sums a\n  // list of integers.\n  //\n  // You must not alter the definition of \"sumTailAux\".\n  //\n  // Your definition for \"sumTail\" must call \"sumTailAux\" directly, and must\n  // not call \"sum\"\n  def sumTailAux(xs: List[Int], accumulator: Int): Int =\n    xs match\n      case Nil     => accumulator\n      case y :: ys => sumTailAux(ys, accumulator + y)\n\n  def sumTail(xs: List[Int]): Int =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 8: complete the following definition of the function \"max\" that\n  // finds the maximum integer in a list of integers.\n  //\n  // If the list is empty, throw a java.util.NoSuchElementException (with no\n  // argument).\n  //\n  // Your function MUST be recursive and MUST NOT use a while loop.\n  //\n  // You MUST NOT use the \"max\" method on lists, but can use the \"max\" method\n  // on integers: That is, you cannot use (xs.max) or similar.  But you can\n  // use (1 max 2).\n  def max(xs: List[Int]): Int =\n    // TODO: Provide definition here.\n    throw NoSuchElementException()\n\n  // EXERCISE 9: given the definition of the function \"maxTail\" below,\n  // complete the definition of the function \"maxTailAux\" so that \"maxTail\"\n  // also finds the maximum of a list of integers.\n  //\n  // You must not alter the definition of \"maxTail\".\n  //\n  // Your definition for \"maxTailAux\" must be recursive and not use while\n  // loops.\n  def maxTailAux(xs: List[Int], accumulator: Int): Int =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  def maxTail(xs: List[Int]): Int =\n    xs match\n      case Nil     => throw NoSuchElementException()\n      case y :: ys => maxTailAux(ys, y)\n\n  // EXERCISE 10: Write a recursive function \"otpu\" (\"upto\" backwards) that\n  // takes two Int parameters \"start\" and \"end\" and produces a \"List[Int]\"\n  // that counts DOWN from \"start\" to \"end\" (inclusive at both ends) one at a\n  // time.\n  //\n  // If \"start < end\", the empty list must be returned.\n  //\n  // For example:\n  // - otpu(10,5) == List(10,9,8,7,6,5)\n  // - otpu(10,11) == Nil\n  def otpu(start: Int, end: Int): List[Int] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, shutdown, [true,null])[0m
[0m[[0m[0minfo[0m] [0m[0mshutting down sbt server[0m
